# 入門Unixシェルプログラミング

# 一章
## コメント
`#`から行末までがコメントになる

```shell
#!/bin/sh
# この行はコメント1
# この行もコメント2
echo "Hello World!" # ここもコメント
```

## 1行の扱い
`\`の直後の改行は無視される

```shell
$ echo hello\
>world
helloworld

$ echo hello \
>world
hello word

# 複数のスペースは一つに置き換えられる
$ echo hello     \
>world
hello world

# 複数のスペースを入れたい場合はダブルクォーテーションでくくる
$ echo "hello   \
>world"
hello    world
```

## バックスラッシュ
直後の1文字をエスケープする

```bash
$ echo abc\def
abcdef

$ echo abc\\def
abc\def
```

## シングルクォーテーション
シェルのクォーテーションで一番強力なもの。すべて普通文字の扱いとなる。

シングルクォートでエスケープできないのはシングルクォートだけ

```bash
$ echo 'abc\def'
abc\def
```

## ダブルクォーテーション
ほとんどの特殊文字はエスケープできる。

しかし、$、`、\の3つの特殊文字はエスケープできない(シングルクォーテーションを使う)

注意点としては、`\` の直後にある$、`、\、"はエスケープされる。それ以外の場合は\が表示される

```bash
$ FOO=foo
$ echo $FOO
foo

$ echo "$FOO"
foo

$ echo "\$FOO"
$FOO

$ echo "F\OO"
F\OO

$ echo '$FOO'
$FOO

echo '\$FOO'
\$FOO
```

## クォーテーションの使い分け

ダブルクォートとシングルクォートの使い分けとして、「囲んだ文字列の中で、変数の置き換えやコマンド置換した結果を使いたいときはダブルクォートを使用する

```bash
$ FILE=foobar
$ echo "Cannot remove $FILE"
Cannot remove foobar

$ echo 'Cannot remove $FILE'
Cannot remove $FILE

$ echo "Tody is `date`"
Tody is Thu Dec 19 22:32:16 JST 2019

$ echo 'Today is `date`'
Today is `date`
```

## バッククォートによるコマンド置換

バッククォートは、その名kに書かれたコマンドを実行し、その結果をその１に書き込む

```bash
$ echo "Tody is `date`"
Tody is Thu Dec 19 22:32:16 JST 2019

# 最初にecho defの部分が添加され、defに置き換わります。次にecho abc def ghiが処理され、その値がSTRINGに入る
$ STRING=`echo "abc \`echo def\` ghi"`
$ echo $STRING
abc def ghi

# 上のやつをくどく書くと
$ TMPSTR=`echo def`
$ STRING=`echo "abc $TMPSTR ghi"`
$ echo $STRING
abc def ghi
```

## コマンドの終了ステータス

コマンドは普通、慣例として、正しく終了したときは0、そうでないときは1を終了時にセットする。

- 0 : 成功 : true
- 0以外 : 失敗 : false

## コマンドセパレート

### セミコロン

左から順に実行される。改行の箇所にセミコロンを置いたもの。

利点としては複数行になるコマンドを1行にまとめることができる

```bash
$ cd /tmp; ls

# ↑と全く同じ動作
$ cd /tmp
$ ls
```

### パイプ(|)

処理を左から右へ流していく意味でパイプライン処理と言う

| の左側で実行したコマンドの結果を、| の右側のコマンドの入力として処理する

```bash
$ echo abc | wc
1 1 4
```

### バックグラウンドでの実行

& をコマンドの後ろにつけると、そのコマンドはバックグラウンドで実行される

```bash
# 5秒間プロンプトが表示されない
$ sleep 5

# すぐにプロンプトが表示される
$ sleep 5 &
```

### OR演算子

||をOR制御演算子と呼ぶ。

コマンドの間に入れて実行すると、左側のコマンドが失敗したとき初めて右側のコマンドを実行する。

ORだからまたはと解釈すると混乱するので注意

```bash
# ファイルの削除に失敗したら、メッセージが表示される
$  rm file || echo "ERROR - Cannot remove file"
```

### AND演算子

&& をコマンドに間に入れて実行すると、左側のコマンド成功した(0を返した)ときだけ、右側のコマンドを実行する。

```bash
# ディレクトリを作成できた場合、ファイルをコピーする
$ mkdir dir && cp file dir
```

## コマンドのグルーピング

### 丸括弧()のグルーピング

括弧で囲まれたコマンドは現在の動作しているシェルとは別に、サブシェルのもとで動作する。サブシェルがあ終了するまで次の処理には移行しない。


親の環境は子の環境(サブシェル)に引き継がれるが、このシェルで変更した環境は親には影響しない

```bash
# 現在どこのディレクトリにいようが、makeが実行されるのはmakedir
# そして、makeが終了すると、makedirディレクトリではなく、もとのディレクトリにいる
$ (cd $HOME/makedir; make)
```

### 中括弧のグルーピング

現行のシェルで実行される。中括弧を使うのは普通、それぞれのコマンド結果をひとまとめにしたいようなとき。

```bash
# makeコマンドの出力結果の前に、その日の日付を挿入することができる
$ { date; make; } > make.list
```

## 制御文

### if文

```bash
if command-list
then
  command
  ・・・・
elif command-list2
then
  command
  ・・・・
else
  command
  ・・・・
fi
```

```bash
# fileがあるかないかで、メッセージを分ける
if test -f file
then
  echo "The file exist"
else
  echo "the file does not.exsit"

# ifと同じ行にthen書くものをよくやること。注意するのは、そのときはthenの前にセミコロンを付ける必要がある
if test -f file; then
  echo "The file exist"
else
  echo "the file does not.exsit"
```

### for文

```bash
for variable in word-list
do
  command
  ・・・
done
```

```bash
for i in a b c d
do
  echo $i
done
```

### while

```bash
while command-list
do
  command
  ・・・・
done
```

```bash
a=1
while test $a -lt 3
do
  echo $a
  a=`expr $a + 1`
done
```

### case文

```bash
case string in
  pattern1) command-list ;;
  pattern2) command-list ;;
  pattern3) command-list ;;
  ・・・・
esac
```

```bash
STRING=abc
case "$STRING" in
  ABC) echo "STRING is ABC" ;;
  abc) echo "STRING is abc" ;;
  xyz) echo "STRING is xyz" ;;
esac
```

### testコマンド

testコマンドは、ある条件を判定し、その条件が正しい場合には真(0)を返し、誤っている場合には偽(0以外)を返す。ifやwhileのような条件判定文で使いやすコマンド

```bash
if test -r file
then
  echo "the file exists and i can read it"
fi

# もっと読みやすいように鉤括弧で置き換えることができる
if [ -r file ]
then
  echo "the file exists and i can read it"
fi
```

# ２章

## シェル変数

- アルファベット、数字、アンダースコアを使うことができる
※1文字目は数字はNG
- シェルの変数名は大文字を使うことが慣例になっている

```bash
# 正しい変数のセット
variable1=value

# =の両脇にスペースを入れるとえらーになる
variable1 = value

# 複数の変数を1行にセットする場合はスペースで区切る
variable1=value1 variable2=value2
```

## シェル変数の中身の確認

`$variable` もしくは `${variable}`のようにする。$や{}はこれが変数であることを示すためのもの。{}で括ったほうが分かりやすい

```bash
$ FOO=abc
$ echo $FOOBAR
$
$ echo ${FOO}BAR
abcBAR
```

## シェル変数の初期設定

### =によるシェル変数の設定

```bash
# 変数variableを展開するとき、未使用がヌル値であればvalueを使用する
${variable:=value}
# ヌル値が入っている場合は既存のものを使用する
${variable=value}
```

```bash
$ echo ${ABC:=xyz}
xyz
$ echo $ABC
xyz
$ echo ${ABC:=abc}
xyz
$ ABC=""
$ echo ${ABC=123}
$
$ echo ${ABC:=123}
$ 123
```

### -によるシェル変数の設定
= と違うのは変数が未使用、未設定の状態の時値を代入しないまま、指定した値を返す

```bash
# 変数variableを展開するとき、未使用がヌル値であればvalueを使用する
${variable:-value}
# ヌル値が入っている場合は既存のものを使用する
${variable-value}
```

```bash
$ echo ${ABC:-xyz}
xyz
$ echo $ABC
$
$ echo ${ABC:=xyz}
xyz
$ echo $ABC
xyz
```

もう一つ=とことなるのは、-だと位置パラメタが使えること

`echo The variable ${1:-abc} will be used`

$1に何かしらの値がセットされていればそのまま使う。$1が未定義、未使用ならばabcという結果を返す。つまり、変数が書き込み禁止であっても置き換えて使用しているように見える。

### ?によるシェル変数の設定

?は、変数がこれまで未使用、未設定であるかどうかを確認するときに使う。変数がこおれまで未使用、未設定のときにmessageの部分が標示される。さらに、シェルスクリプトの場合は、そこで処理が終了する。

```bash
# 変数variableを展開するとき、未使用がヌル値であればmessageを使用する
${variable:?message}
# ヌル値が入っている場合は既存のものを使用する
${variable?message}
```

```bash
$ echo ${ABC:?"ABC is no set"}
-bash: ABC: ABC is no set
```

### +によるシェル変数の設定

-を使用したときによく似ている。変数に何らかの値が設定されている時、値を取り替えて標示する。もとの変数の値は変更しない。つまり、変数の値を変更せずにそのときだけ結果を変えたい場合に利用する

```bash
${variable:+value}
${variable+value}
```

```bash
$ echo ${ABC:+zzz}
$
$ ABC=www
$ echo ${ABC:+zzz}
zzz
$ echo $ABC
www
```

## 位置パラメタ

`./nnn.sh a b c d e f g h i` を実行すると、順に$0 〜 $9に値が入る($0は./nnnが入る。コマンド自身)

`$#`はコマンドに渡される引数の数が入る。この値は実際にそのコマンドに与えられて引数の数であり、$0に該当するコマンド自身は数に入らない。

引数全体を表現するには、`$*`と`$@`という2種類ある。2つの違いはダブルクォートで囲んで使用した場合の展開の方法にある。

- `$*`をダブルクォートで括ると、引数全体を1個のダブルクォートで囲んだ状態で展開する
- `$@`をダブルクォートで括ると、引数をそれぞれ1個ずつダブルクォートで囲んだ状態で添加する

## 特殊な変数

### $? 変数

コマンド実行時の終了ステータスを表す変数。&を使いバックグラウンドで実行させたコマンドに対して無効です。

コマンドは、通常実行終了時に、正常終了の場合は真(0)、異常時終了(0以外)の値がセットされる。

```bash
command
if [ $? -eq 0 ]
then
  ・・・
fi

# 上記は次と同じ
if command
then
  ・・・
fi
```

### $$変数

変数$$には、現在動作しているコマンドの「プロセスID」がセットされる。

プロセスIDというのは、UNIX上で管理されるものであり、何かコマンド実行されたときに、必ずそのUNIX上で一意に決定されて割り当てられる。

```bash
$ echo $$
43722
```

### $!変数

&を使ってコマンドをバックグランドで走らせたとすると、そのコマンドのプロセスIDが$!にセットされる。

```bash
command &
・・・
wait $!
```

waitコマンドは、引数のPIDを持つバックグラウンドジョブが終了するのを待つということ。上の例は、commandというコマンドをバックグランドで実行させ、・・・部分で何か別の処理をする。そして先程のバックグラウンドの処理が確実に終わるのを待ってから、この先に進めるということ。

### $- 変数

$-という変数には、そのシェルの起動時フラグや、setコマンドを使って設定したフラグの一覧がセットされている。

```bash
$ echo $-
himBH
```

この場合は、今動作しているシェルはh,i,m,B,Hという3つのフラグが指定されている。`/bin/bash -himBH`という形で実行されている。

## コマンド行上での変数の設定

コマンドを実行するとき、そのコマンドだけに有効になるよう変数を設定することが可能

`$ CFLAGS=-g make`

このようにmakeコマンドを実行すると、CFLAGSという変数に値がセットされた状態で実行される。

# 3章

## シェル関数

下記が基本の形。nameという名前の関数ができあがる。普通のコマンドを実行するようにnameとすれば、中括弧で囲んだ部分が動作する。

関数名のあとの丸括弧は関数の定義として必要なもの。普通は、その中には何も書かない.

```bash
name()
{
  command
}
```

`return [n]`

関数では戻り値を設定できる。[n]と書いている部分に任意の番号を設定すれば、それがこの関数の戻り値となる。ここで返す値は`$?`で参照可能で、ifやwhileの条件判定に使用できる。returnb文を明示的に書いていない場合は、戻り値は「関数内の最後にじっこうさあれたコマンドの実行終了ステータス」となる。

### 関数をカレントシェルで利用すること

```bash
#!/bin/bash
pse()
{
  ps- ac |  sort -bn
}
```

```bash
$ ./aaa
$ pse
pse: not found

$ . ./aaa
$ pse
実行結果が標示される
```

ドットコマンドを使うことで、シェルスクリプト内で定義された関数を現在のシェルから利用できるようになる。

## 組み込みコマンド

### ヌルコマンド(:)

何もしないがいつも成功する(真の結果を返す)コマンド。実行終了ステータスで0を返す。`:`と書く。

条件判定式で必ず真にしたい場合などに使用することが多い

```bash
while :
do
  if ・・・
  then
    break
  fi
done
```

また、何かコマンドを書かなくてはならないような状態で、実際は何もしたくないときにも、使える。

```bash
# thenのあとにコマンドが必要なため、ヌルコマンド使用している
if command-listt
then
  :
else
  command
fi
```

### ドットコマンド(.)

`. file`

という形で使用するもの。ピリオドがそのコマンド。これは普通のコマンドとは違い、新しくプロセスを作らずに現行のシェルのプロセスを使って指定されたファイルを読み込み実行する。指定されたファイルで記述されている変数や関数が、現行のシェルで有効に使えるようになる。

### breakコマンド

`break`

forやwhileのループから抜け出るときに使用するコマンド。

デフォルトでは1個のループを抜ける。ループがネストしているうときに、複数を脱したときには引数を指定する。


`break number`

### cdコマンド

`cd [directory]`

引数で指定したディレクトリに移動する。


### continueコマンド

`continue`

forやwhileのループ内で、いったんループ内の処理を終えて次の繰り返しに意向させたい場合に使用する。

breakと同じようにループがネストしている場合は引数を設定できる

`continue number`

### echoコマンド

`echo parameter`

引数の部分を標準出力(画面)に表示するコマンド

### evalコマンド

```bash
$ VAR1=value
$ VAR2=VAR1

# このとき、VAR2という変数を使ってVAR1に代入したvalueを標示させたい

# 一回目しか展開されない
$ echo $"$VAR2"
VAR1

# $$というプロセス番号への変換処理が先に処理される
$ echo $$VAR2
43722VAR2

# 複数の変換処理を一度にする場合は、evalを使用する
$ eval echo \$$VAR2
value
```

evalコマンドは、変数の置換やコマンドの置換、ワイルドカードの展開などが複雑に絡んでいるときに、1行のコマンドでいっぺんに展開させてしまうのもの。

記述法は、`eval string`

### execコマンド

`exec command`

execコマンドは、新しくプロセスを作らず現行のカレンドシェルのプロセスと置き換えて、引数のコマンドを実行させる。このコマンドを実行したら、もうもとのシェルに戻ることはない。

```bash
#!/bin/sh
exec ls -l
echo abc
```

execコマンドでlsが起動された時点でシェルスクリプトのプロセス自体がlsのプロセスに置き換わるので、その後のechoコマンドは実行されない。

### exitコマンド

exitコマンドはシェルを終了するときに使用する。

シェルスクリプト実行中に何かしらのエラーが発生した時、その時点で実行をやめたい場合にこのコマンドを使う。

`exit number`

番号を引数にすることでシェルスクリプトの終了コード指定することができる。この終了コードは`$?`変数に渡される。

シェルスクリプトの終了で、exitコマンドで明示的に番号を指定することが望ましいた。

### exportコマンド

`export name`

このように書くことで、nameで指定した変数を、他のコマンドやシェルから利用することができる。

### pwdコマンド

カレントディレクトリの完全パスを標示する。

### readコマンド

`read variable`

このコマンドは、キーボードからの入力をvariable変数にセットする。

```bash
#!/bin/sh
echo -n "enter yes or no -->"
read ANSWER
```

### readonlyコマンド

`readonly name...`

このコマンドはnameで指定された変数をリードオンリーにする。

### returnコマンド

`return exitstatus`

シェルの関数から抜けるコマンド。exitstatusに指定した番号がその関数の終了コードとなる。番号が指定されなかった場合には、関数が終了する直前のコマンドの実行終了コードが返る。

### setコマンド

setコマンドは、シェルのオプションをオンにしたりオフにしたりする。

```bash
$ sh #シェルを起動
$ echo abc
abc
$ set -v #冗長モード
$ echo abc #コマンドを打つと、入力コマンドを表示後、結果がでる
echo abc
abc
$ set +v #オプションをもとに戻す
$ echo abc #入力コマンドが標示されない
abc
```

代表的なオプション

* -i 対話的に動作するようにする
* -n コマンドを読み取るが、実行はしない
* -s コマンドを標準入力から読む
* -v 入力されたコマンドを標準エラーに出力する
* -x コマンドの実行前に、実行するコマンドを標準エラーに出力する

注意点は-をともうなうとそのフラグがオンになり、+が伴うとオフになるということ

### shiftコマンド

このコマンドは、位置パラメタの値を飛騨アリにずらす。

`shift number`

引数としてnumberの所に数値(9まで)を書けば、その数値の文だけずらす。

```bash
#!/bin/sh
echo $0 $1 $2 $3 $4 $5 $6 $7 $8 $9
shift
echo $0 $1 $2 $3 $4 $5 $6 $7 $8 $9
shift 3
echo $0 $1 $2 $3 $4 $5 $6 $7 $8 $9
```

というスクリプトあった場合、下記のような挙動となる

```bash
$ ooo aa bb cc dd ee ff gg hh ii
./ooo aa bb cc dd ee ff gg hh ii
./ooo bb cc dd ee ff gg hh ii
./ooo ee ff gg hh ii
```

### testコマンド

testコマンドは、ある条件を判定し、正しいか正しくないかによって真(成功、0の値)か(失敗、0以外)を返す。ifやwhileの条件判定に使うのがもっとも多い利用。

書き方は次の二通りある

* test expression
* [ expression ]

下記、判定オプションの一礼

ファイルに関するテスト
```
-r file #fileが「読み取り可」なら真
-w file #fileが「書き込み可」なら真
-x file #fileが「実行可」なら真
-f file #fileが「普通のファイル」なら真
-d file #fileが「ディレクトリ」なら真
-s file #fileが「0より大きいサイズ」なら真
```

文字列に関するテスト
```
-z string #stringの「長さが0」なら真
-n string #stringの「長さが0より大」なら真
string    #stringが「ヌルでなければ」真
str1 = str2 #str1とstr２が「同じ」なら真
str1 != str2 #str1とstr2が「同じでない」なら真
```

数値に関するテスト
```
int1 -eq int2 #int1とint2が「等しい」なら真
int1 -ne int2 #int1とint2が「等しくない」なら真
int1 -lt int2 #int1がint2「より小さい(less than)」なら真
int1 -le int2 #int1がint2「以下(less than or equal)」なら真
int1 -gt int2 #int1がint2「より大きい(greather than)」なら真
int1 -ge int2 #int1がint2「以上(greather than or equaql)」なら真
```

その他
```
! #NOTの意味
-a # AND
-o # OR
( expr ) #グルーピング
```

### trapコマンド

`trap action signal...`

このシェルスクリプトが、signalに指定したシグナルを受け取ったときにどういう処理をするかをactionの所に指定する。

### typeコマンド

`type name`

nameには普通コマンドの名前を指定する。typeコマンドは、nameで指定したコマンドが、このシェルでどういう取り扱いなのかを出力する。

```bash
$ type echo date
echo is a shell builtin
date is /bin/date
```

### umaskコマンド

`umask mask`

ファイルを生成するときにどういうモードで作るかを決定する。

```bash
OLDMASK=`umask` #現在の値を保存
umask 002 #変更していろいろ操作
・・・・
・・・・
umask $OLDMASK #もとに戻す
```

### unsetコマンドは

unsetこまんどは、以下のようにして指定した変数や関数を消去する

`unset name`

### waitコマンド

`wait jobnumber`

引数に指定するのは動作しているプログラムのプロセスIDです。このコマンドは、そのプログラムが終了するまでずっとまちます。

# 第4章 リダイレクションによるファイル操作

## ファイルディスクリプタ

プロセスとそれが使用するファイルとの結びつけをする。何かプログラムがファイルを作成して書き込みを行う場合など、プロセスはファイルディスクリプタを使ってっ対象となるファイルへアクセスをする。

ファイルディスクリプタは、ファイルディスクリプタ0番、ファイルディスクリプタ5番というように、数値で表現される。

|ファイルディスクリプタ| 意味 |
|---|---|
| 0 | 標準入力(普通はキーボードからの入力) |
| 1 | 標準出力(普通は端末画面への出力) |
| 2 | 標準エラー(普通は端末画面への出力) |

## リダイレクション

「普通は」キーボードからの入力であり、「普通は」端末画面への出力であると書く。この「普通の入力元や出力先」を変えることをリダイレクションという。この機能をつかうことで、例えばファイルからデータを入力したり結果をファイルに書き出したりすることができる。

リダイレクト起動としては、「>」と「<」を基本的に用いる。

```bash
$ echo abcdefg      # echoは「標準出力」に書く
abcdefg      　　　  # 結果は画面に標示される
$ echo abcdef > abc # 出力をファイルabcに向ける
$                   # 画面に出力されない
$ cat abc           # ファイルabcにechoした内容が書き込まれた
abcdef

$ echo 123456 > abc # 別の出力を書き込んでみる
$ cat abc           # abcの内容を見る
123456
$ 
$ echo xyz >> abc   # >>というリダイレクト記号を使うと、
$ cat abc           # 結果は追加されている
123456
xyz
```

何らかの出力を > でリダイレクトし、ファイルに結果を書き込もうとしたとき、そのファイルが既に存在していたら中身はクリアされる。クリアせずに追加で書きたい場合には、リダイレクト記号として >> を使う。

```bash
$ cat abc xxx # abcとxxxというファイルをcatする
123456        # abcの中身は表示されるが、
xyz           # (↓)xxxというファイルは存在しないのでエラー
cat: xxx: No such file or directory
$ cat abc xxx > nnn # 同じことをリダイレクトすると
cat: xxx: No such file or directory #エラーだけが画面にでる
$
```

nnnというファイルにはabcの中身が書かれた。そしてエラーメッセージは画面にそのまま表示される。エラーメッセージは標準エラーに出力されたもの。

通常は標準出力も標準エラーも画面に出力されるので区別はつかないが、理大レクトを用いると別のものと分かる。

標準エラーが画面に標示される理由は、>というリダイレクト記号は標準出力の向きだけを変えたからである。

正確に書くと、`echo abcdef 1>abc` となる。これは、1番のファイルディスクリプタを経由するものを、abcというファイルに向けなさい、という意味。1は省略可能なので、通常は>と書き表す。

エラーメッセージだけをファイルに書くには、以下のようにする

```bash
$ cat abc xxx 2> nnn # 標準エラーの2番ファイルnnnに向ける
abcdef               # abcの内容は標準出力に書かれるから
xyz                  # このように画面に標示される
```

標準出力と標準エラーをひとまとめにリダイレクトする書き方。

```bash
# 標準出力をnnnというファイルに書くように指示。そして、標準エラーは標準出力に書くようにリダイレクトをしている。2>&1はファイルディスクリプト2番を1番と一緒にまとめるということ。
$ cat abc xxx > n 2>&1
```

リダイレクト記述法

```bash
>file   標準出力をfileというファイルに書く
>> file 標準出力をfileというファイルに追加で書き込む
>&m     標準出力をm番のファイルディスクリプタに書く
>&-     標準出力をクローズする

<file   標準入力をfileというファイルから読み込む
<&m     標準入力をmというファイルディスクリプタから読み込む
<&-     標準入力をクローズする
<<word  標準入力をヒアドキュメントから読み込む
```

上記の書き方は、デフォルトのファイルディスクリプタ(1と0)を省略できる。

リダイレクト記号はコマンド行のどこに置いてもよいが、下記のように最後に書くのが一般的

`$ command param1 param2 .... >/dev/null`

## リダイレクトを使った書き込み(>、>>)

```bash
# fileというファイルが既に存在していれば上書きする。
# ファイルが存在しなければ新規作成する
$ command > file

# ファイルを上書きするのではなく、追記をする
# ファイルが存在しなければ新規作成をする
$ command >> file

# 標準エラーをリダイレクトする
$ command 2>  file
$ command 2>> file
```

ファイルディスクリプタの番号を明示的に指定すれば、そのファイルディスクリプタが向いている出力先を別のファイルに変更することが可能

`command n>&m`

この場合、ファイルディスクリプタn番をm番に向ける。nが省略されたときは、標準出力の1がデフォルトを使う。

echoコマンドは標準出力にメッセージを標示する。よってシェルスクリプトの中で、エラーが発生したときにechoコマンドを使ってメッセージを出力させてもそれは標準エラーには書き込まれない。この場合、シェルスクリプト中で、「エラーメッセージをエラーとして出したい」ときには以下のように書けばいい。

`echo "Error messages." 1>&2`

## リダイレクトを使った読み込み(<、<<)

標準入力もリダイレクトすることができる。すなわち、キーボードから入力せずファイルから入力させることができるということ。

`command < file`

また、`<<`を使えば、ファイルを使わずに「そこに書いてあるテキスト」をそのまま入力することができる

```bash
command << word
 ・・・
 ・・・
word
```

これはヒアドキュメントという。<<のあとに任意のワードを書くと、次にその同じワードが出てくる行までに書かれたテキストを標準入力からのものだと解釈する。上の例では・・・の部分に書いた文字列が、commandへのキーボード入力として扱われる。

## 制御構文とリダイレクション

- グルーピングしたコマンドに対して：

```bash
{
  command
  ・・・
} > stdout
```

- if文：

```bash
if command-list
then
  command
  ・・・
fi > stdout
```

- for文：

```bash
for variable [ in word-list ]
do
  command
  ・・・
done > stdout
```

- while文：

```bash
while command-list
do
  command
  ・・・・
done > stdout
```

- case文：

```bash
case string in
  pattern) command-list ;;
  ・・・
esac > stdout
```

ifやwhileが完全にクローズしたところでリダレクトさせることで、その中で行われた処理の全部がひとまとめに渡されることになる。stdoutの所に出力ファイル名を指定する。

## execコマンドとリダイレクション

execコマンドは、現在のシェルのプロセスをそのまま置き換えて新しいコマンドを実行させるもの。この機能を逆手に取り、execコマンドに何も引数を与えず、リダイレクト記号だけを書くことで現行のシェルに対してリダイレクト処理を行わせることができる。

```bash
$ echo abc
abc
$ exec >/dev/null #シェルの標準出力を/dev/nullにリダイレクトする
$ echo abc #出力がリダイレクト先にいった
$ cat aaa # 存在しないファイルをオープンする
cat: aaa: No such file directory # 標準エラーは出力される
```

execを使ったシェルの入出力のリダイレクションには、以下のような用法がある

```bash
exec < file # fileから入力する
exec 1<&2   # 標準出力を標準エラーに向ける
exec 2< /dev/null # 標準エラーを捨てて画面に出さないようにする
exec > /dev/null 2>&1 #標準出力と標準エラーをすべて捨てる
exec >>file # 標準出力をfileに追加する
```

## ファイルからの読み込み

readコマンドは入力を読み込んで変数にセットするもの

```bash
read ANSWER
if [ "$ANSWER" = "yes" ]; then
  ・・・
else
  ・・・
fi
```

このようにすることで、シェルスクリプトの中で入力を待ち、この値がyesであれば・・・する処理をすると書ける。

リダイレクト記号を使用することでファイルから読み込ませることができる。readコマンドでは改行コマンドまでが渡るので、複数行あると2行目以降は取得できない。

しかし、readをwhile文と使用することで操作可能となる。

```bash
# fileから1行読み取りそれをLINEという変数に代入してdoからdoneの間で何かしらの処理をさせる
while read LINE
do
  ・・・
done < file
```

## ファイルのゼロリセット

ファイルの大きさを0にしたいときや、何も書かれていないファイルを作成したいとき、以下の方法で行うことができる

```bash
$ >file
$ :>file

$ cat /dev/null > file
$ cp /dev/null file
```

エディタでファイルを開いて中身を削除してしまっても1バイトは残るため、0にしたい場合は上記のようにする必要がある。

## ヒア・ドキュメント(Here Documents)

`<< word`

wordという部分にはどういう言葉を使ってもよい。この場合、このあとwordという言葉が「行頭に、しかもそのいちごだけの行として」出てくるまでの間に書かれたテキストがすべて標準入力からのものとして処理される。

「ここまでを入力のデータとして扱うよ」の意味をできるだけ明示的にするために、wordの部分にはEOFやENDという言葉をよく使う。

```bash
command << EOF
・・・・
・・・・
END
```

こう書くと、・・・・の部分がcommandの入力として扱われる。

```bash
$ cat
> this is a
> input data.
> ^D
this is a
input data.

# これを、<<を使って書き換えると次のようになる
$ cat << END
> this is a
> here document.
> END
this is a
here document
```

<<のあとに指定した文字列が現れるまでを、そのコマンドの入力として扱える。

```bash
$ DOC=document
# $DOCは展開されるｆｄｓ
$ cat << END
> this is a
> here $DOC
> END
this is a
here document.

# $DOCの文字列をそのまま処理させたい場合は、<<に続く文字列を\でクォートすれば良い
$ cat << \END
> this is a
> here $DOC
> END
this is a
here $DOC

# 個別にクォートすることもできる。
# クォートするもの、しないものが混在する場合に使用する
$ cat << END
> this is a
> here \$DOC
> END
this is a
here $DOC

# <<のあとに、-(ハイフン)を付けることができる。そうすると、行頭のタブは入力されていないものとして処理される
# インデントを使ってスクリプトを読みやすくする際に便利
$ cat <<- END
> <tab>this is a
> <space><space>here document.
> END
this is a
  here document
```

# 第５章: 環境

## 環境変数

環境変数はプロセスが作られたときに引き継がれる「名前とその値」が組になったものをいう。これはプロセスができるときに親の環境をコピーする。

これはあくまでコピーして利用されるものであり、そのプロセスで値を変更しても、元の(親の)値には影響を与えない。

`env` コマンドで今セットされている環境変数の一覧が得られる

## 子の環境を変更する

普通に変数の値を設定したり変更したりしても、その変数が環境変数になるわけではない。環境変数を追加・変更するには、exportコマンドを使う。このコマンドによって、他のプロセスが普通の変数の値を環境変数として認識できるようになる。

```bash
# このようにすることで、makeにこの値を認識できるようになる
$ CFLAGS=-g
$ export CFLAGS
$ make

# こうしたexportした変数は、このmake以外のコマンドやプロセスにも影響を与える。
# それを避けて、ある一部部分にだけに影響するようにしたい場合に下記のように丸括弧で囲みそのサブシェルだけで実行するようにする
(CFLAGS=-g; export CFLAGS; make)

# あるいは以下のように書くことも可能
CFLAGS=-g make
```

## 親の環境を変更する

基本的に、プロセスが異なるため、親の環境を変更することはできない。

2つのプロセスの間で情報を交換したいのなら、何かファイルを仲立ちにさせることが基本的なやり方である。このプロセスの方でセットしたり変更したものをファイルに書き込んで、そのあと親プロセスがそれを読み込み同じように変更させるもの。

## PATH変数

PATH変数にはディレクトリの一覧が入っている。何かコマンドを打った時、このディレクトリを順番にそのコマンドがあるかないかを調べていく。

```bash
$ echo $PATH
/bin:/usr/bin:/usr/local/bin:
```

このようにPATH変数が定義されれいる場合に、/binと/usr/local/binディレクトリの下に、それぞれabcという名称のコマンドがあったなら/bin/abcというコマンドが実行される。

自分の書いたシェルスクリプトや、自分の作ったコマンドを普通のコマンドとして使用したい場合、PATH変数にそれらがおいてあるディレクトリを追加すればよい。

```bash
PATH=$PATH:$HOME/mycmd; export $PATH
```

## ユーザ情報、マシン情報

### ユーザ名の取得

USERあるいはLOGNAMEという環境変数があり、現行ユーザの名前がこの変数にセットされている。

ユーザの名前を知るには、whoami、logname、id、whoといったコマンドから得ることができる

```bash
$ whoami
user
$ logname
user
$ id
uid=1001(user) gid=1001(usergrp)
$ who
user Nov 17 22:49
user ttys000  Dec 29 12:47
```

### マシン名称の取得

hostnameコマンド、そのマシンの名称を取ってくることができる。

```bash
$ hostname
host
```

## シグナルの処理

普通、プロセスはシグナルを受け取ると実行を中断する。シェルではtrapコマンドを使用して、シグナルを受け取ったときにいろいろな処理をさせることが可能になっている。

`trap command-list signal_naumber`

2番目の引数にしてした番号のシグナルを受け取った時、command-list部分のコマンドを実行する。

```bash
trap command-list signal_number # シグナルを受け取って処理する
trap '' signal_number # シグナルを無視をする
trap signal_number # シグナルをリセットする
```

trapコマンドはシェルスクリプトのどこに書いても構わないが、通常はできるだけ初めの方に書く。シェルスクリプトは上から下に順に実行されていくので、trapコマンドを書く以前になにかのシグナルを受け取ってしまうと、そこで中断されてしまうから。